# OSG学习
OSG（OpenSceneGraph）是基于OpenGL的高层次图形开发平台接口，即三维渲染引擎。OSG的学习需要具有OpenGL基础以及C++基础。
- 1、开发预备知识
  - 1.1 四元数，是由3个复数和一个实数组成的复杂数字系统。公式如下：
$$Q_s[x, y, z, w] = x \bullet \overrightarrow{i} + y \bullet \overrightarrow{j} + z \bullet \overrightarrow{k} + w \bullet 1.0$$
其中x,y,z,w是4个实数参数，并且，
$$\overrightarrow{i}^2 = \overrightarrow{j}^2 = \overrightarrow{k}^2 = \overrightarrow{i} \bullet \overrightarrow{j} \bullet \overrightarrow{k} = -1$$
四元数的优势在于：它可以表达物体绕任意像两周的旋转，并且和欧拉角度旋转与旋转矩阵的方法相比，其效率较高，操作也更加灵活。四元数主要的运算方式包括：1）四元数的转置，2）四元数之间的加减法；3）四元数之间的点积，也就是两个四元数个分量乘积之和，结果是一个新的四元数；4）四元数的共轭，即
$$w \bullet 1.0 - x\bullet \overrightarrow{i} - y\bullet \overrightarrow{j} - z\bullet \overrightarrow{k}$$
  - 1.2 包围体，OSG中支持两种类型的包围体，包围球和轴对称包围盒。
  - 1.3 OSG中的内存管理机制，通过引用计数方式进行场景对象的管理，如果三维对象引用为0则将其从内存中释放。
  - 1.4 智能指针，
- 2、场景的组织结构
  - 2.1 节点的定义与种类，OSG采用包围体层次（Bounding Volume Hierarchy， BVH）来实现场景图形的管理，采用包围体可以提高各种检测的运算速度。包围体层次的场景图形通常采用树状结构来保存信息。一颗场景树包括一个根节点、多级内部的枝节节点，以及多个末端的叶子节点。根节点和枝节点负责构建树的层次，以及完成某些特定的功能；叶子节点则保存了可绘制对象的信息。 OSG采用Node类表达一个基本节点。
  - 2.2 节点的父子关系，根系节点没有父节点，叶子节点没有子节点，OSG场景结构可以视为一个有向无环图。多个父节点可以共享一个子节点，减少内存占用，称为对这个子节点的实例化。在OSG中叶子节点为Geode节点，枝节节点为Group节点。Geode节点可以用来保存和管理一个或多个可绘制物体的信息，这可绘制物体的容纳者称为Drawable类。
  - 2.3 节点的功能和分类，叶子节点Geode管理和绘制多个Drawable对象。Group节点最基本的功能是作为场景树结构的枝节存在，将子节点成组进行管理和调度。当一个Group节点的性质发生变化时，其所有子节点也会随之发生类似的变化。1）空间变换节点，通过改变自身在三维空间中的位置和姿态，进而影响子节点的空间位置变化。OSG中使用Transform类来表达空间变换节点。2）开关节点，控制对象的显示与隐藏，OSG中使用Switch和MultiSwitch类来表达开关节点。3）细节层次节点，基本思想是在不影响渲染外观的前提下，根据实际情况选择一种更为简单的方式来表达要渲染的物体，减轻系统绘制场景的负担。OSG种LOD类支持对普遍的静态离散细节层次节点。4）相机节点，通过多部相机完成渲染，OSG中使用Camera类来实现。5）投影节点；6）渲染属性节点，7）覆盖节点，OverlayNode，将子节点渲染结果覆盖到了另一个场景的指定对象上。8）遮挡裁减节点，通过场景裁减，剔除不会被用户看到以及不会过多影响场景绘制结果的对象，OSG中OccluderNode类完成与之相关的操作。9）动态调度节点，动态加载或卸载某些对象，如LOD节点。10）关节节点，可以理解为受限制的空间变换节点。11）代理节点，作为另外一种尚未加载的节点的代理者而存在，被代理的对象会在适当的时候被加载到内存种，在此之前，代理者起到占位符和节省系统启动时间的作用。
  - 2.4 节点访问，访问机制，采用对象行为模式访问器进行节点的访问。节点遍历，采用深度优先遍历形式对场景树进行搜索。节点的更新与事件回调，根据调用时机OSG的回调功能可以分为更新回调和人机交互事件回调。
  - 2.5 重要节点的功能实现
- 3、绘制几何对象和文字
  - 3.1 几何元素的存储，顶点属性是由空间坐标、法线、颜色坐标、纹理坐标、雾坐标等所组成的一个集合。顶点数组为了避免多次调用立即模式的glVertex等顶点设置而造成的冗余和低效。通过多个数组来存储与顶点属性相关的数据，避免了对公用顶点的冗余处理。显示列表是将OpenGL函数调用保存起来，并在需要的时候直接提取内存中的数据，给予调用。顶点缓存对象（VBO）是结合顶点数组与显示列表的优势特性，尽量减少这两者的缺陷。VBO允许将顶点数组保存到显示系统的高速缓存中。
  - 3.2 几何元素的绘制与访问，Drawable类存储在Geode节点中，核心绘制函数为draw()，OSG在每一帧中都会调用该函数。数据的更新显示，通过获取setVertexArray()所用的数组数据，并对其进行更新。但如果开启了显示列表，则数据不能动态更新，因为draw()调用的glCallList()是获取已编译好的显示列表，所以需要调用dirtyDisplayList()进行强制刷新显示列表。几何体的更新回调采用UpdateCallback类，用户需要继承该类然后重写update函数，将新的类通过setUpdateCallback设置到Drawable对象中。同理，Drawable也可以设置事件回调。
- 4、设置纹理和渲染属性
  - 4.1渲染属性与模式，一个节点具有多个渲染状态，包括各种属性和模式，称为一个渲染状态集合，用StateSet表示。渲染状态可以被多个节点共享。
  - 4.2 OSG与OpenGL着色器，OpenGL中着色器分为顶点着色器、片元着色器以及几何着色器。
- 5、观察我们的世界
  - 5.1 OpenGL中的变换，1）模型视点变换，调整物体的位置、姿态，以及调整相机使其对准景物。经视点变换后场景从世界坐标转换为相机坐标系；2）投影变换，相当于拍照时通过选择镜头和调整焦距，将景物投射到二维底片的过程。3）视口变换，将投影变换的结果反映到指定的屏幕窗口上。
  - 5.2 视景器的工作就是高效的将一个或多个相机组织在一起，结合场景节点的更新与遍历，将相机在每一帧所拍摄的内容连续的播放出来。管理场景对应的一个或多个节点树；管理场景中所有的相机，进而管理所有的图形设备；执行场景的仿真循环，持续的执行场景的渲染并将其反映到图形设备上；管理参数场景更新、裁剪和绘制的线程，保证数据的同步性。
- 6、人机交互与图形用户接口
  - 6.1获取鼠标和键盘消息，osg主要通过osgGA库来处理用户的交互动作。
  